//use crate::matches::Match;
//use crate::parser::{self, Parser};
//use crate::ParseError;

pub use crate::parser::{either, empty, exact, lines, opt, plus, sequence, star};

// type of a parser
// `e => rustexpr` => type of the rustexpr (the tricky one)
// `ident: e` => type of e
// `e as ty` => ty
// `e1 e2` => match (type of e1, type of e2) {
//                ((t1, ...), (t2, ...)) => (t1, ..., t2, ...)
//                ((t1, ...), t2) => (t1, ..., t2)
//                (t1, (t2, ...)) => (t1, t2, ...)
//            }
// `e*` => Vec<type of e>
// `e+` => Vec<type of e>
// `e?` => Option<type of e>
// `(e)` => type of e
// `{ e, ...}` => Variant<(type of e, ...)>
// `f(e, ...)` => return type of f (look it up)
// `x` => type of x (look it up)
//
// Other syntax-directed static functions might include:
// - environment generated by the expression before `=>`
// - struct fields (actually the same thing)
// - string label of (used by conversion from Variant to enums)

/// ```text
/// ident ::= a Rust identifier
/// expr ::= a Rust expression
/// literal ::= a Rust literal
///
/// parser ::= rule* expr
///
/// rule ::= "rule" ident "=" expr ";"
///
/// expr ::= label
///   | label "=>" rust_expr        => Map($1, |...pattern of $1...| $2)
///
/// label ::= cast
///   | ident ":" cast              => Label($1, $2)
///
/// cast ::= seq
///   | seq "as" ty                 => TryMap($1, |x| $2::try_from(x))
///
/// seq ::= term
///   | seq term                    => $1.seq($2)
///
/// term ::= prim
///   | term "*"                    => Repeat($1, 0)
///   | term "+"                    => Repeat($1, 1)
///   | term "?"                    => Optional($1)
///
/// prim ::= "(" expr ")"
///   | ident "(" expr,* ")"        => Call($1, $2)
///   | ident                       => NamedRule($1)  -- when not followed by "("
///   | literal                     => Literal($1)
///   | "{" expr,* "}"              => OneOf($1)
/// ```
#[macro_export]
macro_rules! parser {
    // parser!(@seq label [expr] [stack] [patterns])
    // submacro to gradually parse `expr`, producing `stack` and `patterns` (in reverse).
    // `stack` is a list of Rust expressions, parsers for the elements of the `expr`.
    // `patterns` is a list of patterns that match the output of the overall SequenceParser we will build from the bits in `stack`.
    (@seq _ [ => $mapper:expr ] [ $($stack:tt)* ] [ $($pats:pat ,)* ]) => {
        $crate::parser!(@seq _ [] [ $($stack)* ] [ $($pats ,)* ])
            .map(| ( $crate::parser!(@reverse_pats [ $($pats ,)* ] [ () ]) ) | $mapper)
    };
    (@seq $label:ident [ => $mapper:expr ] [ $($stack:tt)* ] [ $($pats:pat ,)* ]) => {
        $crate::parser!(@seq $label [] [ $($stack)* ] [ $($pats ,)* ])
            .map(| $label @ ( $crate::parser!(@reverse_pats [ $($pats ,)* ] [ () ]) ) | $mapper)
    };
    (@seq $label:tt [ as $ty:ty ] [ $top:expr , $($stack:expr ,)* ] [ $($pats:pat ,)* ]) => {
        todo!("cast syntax")
    };
    (@seq $label:tt [ * $($tail:tt)* ] [ $top:expr , $($stack:expr ,)* ] [ $top_pat:pat , $($pats:pat ,)* ]) => {
        $crate::parser!(@seq $label [ $($tail)* ] [ $crate::macros::star($top) , $($stack ,)* ] [ _ , $($pats ,)* ])
    };
    (@seq $label:tt [ + $($tail:tt)* ] [ $top:expr , $($stack:expr ,)* ] [ $top_pat:pat , $($pats:pat ,)* ]) => {
        $crate::parser!(@seq $label [ $($tail)* ] [ $crate::macros::plus($top) , $($stack ,)* ] [ _ , $($pats ,)* ])
    };
    (@seq $label:tt [ ? $($tail:tt)* ] [ $top:expr , $($stack:tt)* ] [ $top_pat:pat , $($pats:pat ,)* ]) => {
        $crate::parser!(@seq $label [ $($tail)* ] [ $crate::macros::opt($top) , $($stack)* ] [ _ , $($pats ,)* ])
    };
    // call syntax
    (@seq $label:tt [ $f:ident ( $($args:tt)* ) $($tail:tt)* ] [ $($stack:expr ,)* ] [ $($pats:pat ,)* ]) => {
        $crate::parser!(
            @seq $label
            [ $($tail)* ]
            [
                $crate::functions::ParserFunction::call_parser_function(
                    &$f,
                    ( $crate::parser!(@args [$($args)*] [] ()) ),
                )
                ,
                $($stack ,)*
            ]
            [ _ , $($pats ,)* ]
        )
    };
    // special case of the next case, where $x is of the form `(ident : parser)`
    (@seq $label:tt [ ( $sublabel:ident : $($expr:tt)* ) $($tail:tt)* ] [ $($stack:expr ,)* ] [ $($pats:pat ,)* ]) => {
        $crate::parser!(
            @seq $label
            [ $($tail)* ]
            [ $crate::parser!(@prim ( $($expr)* )) , $($stack ,)* ]
            [ $sublabel , $($pats ,)* ]
        )
    };
    (@seq $label:tt [ $x:tt $($tail:tt)* ] [ $($stack:expr ,)* ] [ $($pats:pat ,)* ]) => {
        $crate::parser!(
            @seq $label
            [ $($tail)* ]
            [ $crate::parser!(@prim $x) , $($stack ,)* ]
            [ _ , $($pats ,)* ]
        )
    };
    (@seq $label:tt [ /* end of input */ ] [ $($parts:expr ,)* ] [ $($pats:pat ,)* ]) => {
        $crate::parser!(@reverse [ $($parts ,)* ] [ $crate::macros::empty() ])
    };
    (@seq $label:tt [ $($tail:tt)* ] [ $($parts:expr ,)* ] [ $($pats:pat ,)* ]) => {
        ::core::compile_error!(stringify!(unrecognized syntax @ $($tail)*))
    };

    (@reverse [ ] [ $out:expr ]) => {
        $out
    };
    (@reverse [ $head:expr , $($tail:expr ,)* ] [ $out:expr ]) => {
        $crate::parser!(@reverse [ $($tail ,)* ] [ $crate::macros::sequence($head, $out) ])
    };

    (@reverse_pats [ ] [ $out:pat ]) => {
        $out
    };
    (@reverse_pats [ $head:pat , $($tail:pat ,)* ] [ $out:pat ]) => {
        $crate::parser!(@reverse_pats [ $($tail ,)* ] [ ($head, $out) ])
    };

    (@prim $x:ident) => {
        ::core::compile_error!("no support for identifiers yet")
    };
    (@prim $x:literal) => {
        $crate::macros::exact($x)
    };
    (@prim ( $($nested:tt)* )) => {
        $crate::parser!(@seq _ [ $( $nested )* ] [ ] [ ])
    };
    (@prim { $($nested:tt)* }) => {
        $crate::parser!(@list [ $( $nested )* ] [ ] [ ])
    };

    (@args [ , $($tail:tt)* ] [ $($seq:tt)* ] ( $( $arg:expr , )* )) => {
        // end of an argument in an argument list
        $crate::parser!(
            @args
            [ $( $tail )* ]
            [ ]
            (
                $( $arg:expr , )*
                $crate::parser!(@seq _ [ $( $seq )* ] [ ] [ ]) ,
            )
        )
    };
    (@args [ $next:tt $($tail:tt)* ] [ $($seq:tt)* ] ( $( $out:expr , )* )) => {
        // not the end of an arg; just move a token from the input to the holding area
        $crate::parser!(
            @args
            [ $( $tail )* ]
            [ $( $seq )* $next ]
            ( $( $out , )* )
        )
    };
    (@args [ /*end of input*/ ] [ ] $out:expr) => {
        // end of argument list, after trailing comma or empty
        $out
    };
    (@args [ /*end of input*/ ] [ $($seq:tt)+ ] ( $( $out:expr , )* )) => {
        // end of argument list with no trailing comma: infer one
        $crate::parser!(@args [,] [ $($seq)+ ] ( $( $out , )* ))
    };

    (@list [ , $($tail:tt)* ] [ $($seq:tt)* ] [ ]) => {
        // end of first arm of an alternation
        $crate::parser!(
            @list
            [ $( $tail )* ]
            [ ]
            [ $crate::parser!(@seq _ [ $( $seq )* ] [ ] [ ]) ]
        )
    };
    (@list [ , $($tail:tt)* ] [ $($seq:tt)* ] [ $out:expr ]) => {
        // end of a non-first arm of an alternation
        $crate::parser!(
            @list
            [ $( $tail )* ]
            [ ]
            [ $crate::macros::either($out, $crate::parser!(@seq _ [ $( $seq )* ] [ ] [ ])) ]
        )
    };
    (@list [ $next:tt $($tail:tt)* ] [ $($seq:tt)* ] [ $($out:expr)? ]) => {
        // not the end of an arm; just move a token from the input to the holding area
        $crate::parser!(
            @list
            [ $( $tail )* ]
            [ $( $seq )* $next ]
            [ $( $out )? ]
        )
    };
    (@list [ ] [ ] [ ]) => {
        // completely empty alternation
        ::core::compile_error("no arms in alternation")
    };
    (@list [ /*end of input*/ ] [ ] [ $out:expr ]) => {
        // end of alternation after comma
        $out
    };
    (@list [ /*end of input*/ ] [ $($seq:tt)+ ] [ $( $out:expr )? ]) => {
        // end of alternation with no comma: infer one
        $crate::parser!(@list [,] [ $($seq)+ ] [ $( $out )? ])
    };

    (@ $($tail:tt)*) => {
        ::core::compile_error!(stringify!(unrecognized syntax @ $($tail)*))
    };

    (rule $name:ident = $($body:tt)* ; $($tail:tt)*) => {
        todo!("rule syntax")
    };
    ($label:ident : $($tail:tt)*) => {
        $crate::parser!(@seq $label [ $($tail)* ] [ ] [ ])
    };
    ($($tail:tt)*) => {
        $crate::parser!(@seq _ [ $($tail)* ] [ ] [ ])
    };
}
