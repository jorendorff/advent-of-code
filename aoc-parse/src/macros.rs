//use crate::matches::Match;
//use crate::parser::{self, Parser};
//use crate::ParseError;

pub use crate::parser::{either, empty, exact, lines, opt, plus, sequence, star};

// type of a parser
// `e => rustexpr` => type of the rustexpr (the tricky one)
// `ident: e` => type of e
// `e as ty` => ty
// `e1 e2` => match (type of e1, type of e2) {
//                ((t1, ...), (t2, ...)) => (t1, ..., t2, ...)
//                ((t1, ...), t2) => (t1, ..., t2)
//                (t1, (t2, ...)) => (t1, t2, ...)
//            }
// `e*` => Vec<type of e>
// `e+` => Vec<type of e>
// `e?` => Option<type of e>
// `(e)` => type of e
// `{ e, ...}` => Variant<(type of e, ...)>
// `f(e, ...)` => return type of f (look it up)
// `x` => type of x (look it up)
//
// Other syntax-directed static functions might include:
// - environment generated by the expression before `=>`
// - struct fields (actually the same thing)
// - string label of (used by conversion from Variant to enums)

/// ```text
/// ident ::= a Rust identifier
/// expr ::= a Rust expression
/// literal ::= a Rust literal
///
/// parser ::= rule* expr
///
/// rule ::= "rule" ident "=" expr ";"
///
/// expr ::= cast
///   | seq "=>" expr               => Map($1, Box::new(|...fields of $1...| Ok($2)))
///   | ident ":" cast              => Label($1, $2)
///
/// cast ::= seq
///   | seq "as" ty                 => Map($1, |x| $2::try_from(x))
///
/// seq ::= term
///   | seq term                    => $1.seq($2)
///
/// term ::= prim
///   | term "*"                    => Repeat($1, 0)
///   | term "+"                    => Repeat($1, 1)
///   | term "?"                    => Optional($1)
///
/// prim ::= "(" expr ")"
///   | ident "(" expr,* ")"        => Call($1, $2)
///   | ident                       => NamedRule($1)  -- when not followed by "("
///   | literal                     => Literal($1)
///   | "{" expr,* "}"              => OneOf($1)
/// ```
#[macro_export]
macro_rules! parser {
    (@seq [ => $mapper:expr ] [ $($stack:tt)* ]) => {
        todo!("map syntax")
    };
    (@seq [ as $ty:ty ] [ $top:expr , $($stack:expr ,)* ]) => {
        todo!("cast syntax")
    };
    (@seq [ * $($tail:tt)* ] [ $top:expr , $($stack:expr ,)* ]) => {
        $crate::parser!(@seq [ $($tail)* ] [ $crate::macros::star($top) , $($stack ,)* ])
    };
    (@seq [ + $($tail:tt)* ] [ $top:expr , $($stack:expr ,)* ]) => {
        $crate::parser!(@seq [ $($tail)* ] [ $crate::macros::plus($top) , $($stack ,)* ])
    };
    (@seq [ ? $($tail:tt)* ] [ $top:expr , $($stack:tt)* ]) => {
        $crate::parser!(@seq [ $($tail)* ] [ $crate::macros::opt($top) , $($stack)* ])
    };
    // call syntax
    (@seq [ $f:ident ( $($args:tt)* ) $($tail:tt)* ] [ $($stack:expr ,)* ]) => {
        $crate::parser!(
            @seq
            [ $($tail)* ]
            [
                $crate::functions::ParserFunction::call_parser_function(
                    &$f,
                    ( $crate::parser!(@args [$($args)*] [] ()) ),
                )
                ,
                $($stack ,)*
            ]
        )
    };
    (@seq [ $x:tt $($tail:tt)* ] [ $($stack:expr ,)* ]) => {
        $crate::parser!(@seq [ $($tail)* ] [ $crate::parser!(@prim $x) , $($stack ,)* ])
    };
    (@seq [ /* end of input */ ] [ $($parts:expr ,)* ]) => {
        $crate::parser!(@reverse [ $($parts ,)* ] [ $crate::macros::empty() ])
    };
    (@seq [ $($tail:tt)* ] [ $($parts:expr ,)* ]) => {
        ::core::compile_error!(stringify!(unrecognized syntax @ $($tail)*))
    };

    (@reverse [ ] [ $out:expr ]) => {
        $out
    };
    (@reverse [ $head:expr , $($tail:expr ,)* ] [ $out:expr ]) => {
        $crate::parser!(@reverse [ $($tail ,)* ] [ $crate::macros::sequence($head, $out) ])
    };

    (@prim $x:ident) => {
        ::core::compile_error!("no support for identifiers yet")
    };
    (@prim $x:literal) => {
        $crate::macros::exact($x)
    };
    (@prim ( $($nested:tt)* )) => {
        $crate::parser!(@seq [ $($nested)* ] [ ])
    };
    (@prim { $($nested:tt)* }) => {
        $crate::parser!(@list [ $( $nested )* ] [] [])
    };

    (@args [ , $($tail:tt)* ] [ $($seq:tt)* ] ( $( $arg:expr , )* )) => {
        // end of an argument in an argument list
        $crate::parser!(
            @args
            [ $( $tail )* ]
            [ ]
            (
                $( $arg:expr , )*
                $crate::parser!(@seq [ $( $seq )* ] [ ]) ,
            )
        )
    };
    (@args [ $next:tt $($tail:tt)* ] [ $($seq:tt)* ] ( $( $out:expr , )* )) => {
        // not the end of an arg; just move a token from the input to the holding area
        $crate::parser!(
            @args
            [ $( $tail )* ]
            [ $( $seq )* $next ]
            ( $( $out , )* )
        )
    };
    (@args [ /*end of input*/ ] [ ] $out:expr) => {
        // end of argument list, after trailing comma or empty
        $out
    };
    (@args [ /*end of input*/ ] [ $($seq:tt)+ ] ( $( $out:expr , )* )) => {
        // end of argument list with no trailing comma: infer one
        $crate::parser!(@args [,] [ $($seq)+ ] ( $( $out , )* ))
    };

    (@list [ , $($tail:tt)* ] [ $($seq:tt)* ] [ ]) => {
        // end of first arm of an alternation
        $crate::parser!(
            @list
            [ $( $tail )* ]
            [ ]
            [ $crate::parser!(@seq [ $( $seq )* ] [ ]) ]
        )
    };
    (@list [ , $($tail:tt)* ] [ $($seq:tt)* ] [ $out:expr ]) => {
        // end of a non-first arm of an alternation
        $crate::parser!(
            @list
            [ $( $tail )* ]
            [ ]
            [ $crate::macros::either($out, $crate::parser!(@seq [ $( $seq )* ] [ ])) ]
        )
    };
    (@list [ $next:tt $($tail:tt)* ] [ $($seq:tt)* ] [ $($out:expr)? ]) => {
        // not the end of an arm; just move a token from the input to the holding area
        $crate::parser!(
            @list
            [ $( $tail )* ]
            [ $( $seq )* $next ]
            [ $( $out )? ]
        )
    };
    (@list [ ] [ ] [ ]) => {
        // completely empty alternation
        ::core::compile_error("no arms in alternation")
    };
    (@list [ /*end of input*/ ] [ ] [ $out:expr ]) => {
        // end of alternation after comma
        $out
    };
    (@list [ /*end of input*/ ] [ $($seq:tt)+ ] [ $( $out:expr )? ]) => {
        // end of alternation with no comma: infer one
        $crate::parser!(@list [,] [ $($seq)+ ] [ $( $out )? ])
    };

    (@ $($tail:tt)*) => {
        ::core::compile_error!(stringify!(unrecognized syntax @ $($tail)*))
    };

    (rule $name:ident = $($body:tt)* ; $($tail:tt)*) => {
        todo!("rule syntax")
    };
    ($label:ident : $($tail:tt)*) => {
        todo!("label syntax")
    };
    ($($tail:tt)*) => {
        $crate::parser!(@seq [ $($tail)* ] [ ])
    };
}
