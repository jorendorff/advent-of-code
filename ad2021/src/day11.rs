use aoc_runner_derive::*;

#[aoc_generator(day11, part1, jorendorff)]
#[aoc_generator(day11, part2, jorendorff)]
fn parse_input(text: &str) -> anyhow::Result<Vec<Vec<u8>>> {
    text.lines()
        .map(|line| -> anyhow::Result<Vec<u8>> {
            line.trim()
                .chars()
                .map(|c| -> anyhow::Result<u8> {
                    c.to_digit(10)
                        .ok_or_else(|| anyhow::anyhow!("bad char {:?}", c))
                        .map(|u| u as u8)
                })
                .collect()
        })
        .collect()
}

fn flash(grid: &mut [Vec<u8>], r: usize, c: usize) -> usize {
    let mut flash_count = 1;
    let nr = grid.len();
    let nc = grid[0].len();
    for rr in (r.max(1) - 1)..=(r + 1).min(nr - 1) {
        for cc in (c.max(1) - 1)..=(c + 1).min(nc - 1) {
            if (rr, cc) != (r, c) {
                grid[rr][cc] += 1;
                if grid[rr][cc] == 9 + 1 {
                    flash_count += flash(grid, rr, cc);
                }
            }
        }
    }
    flash_count
}

fn step(grid: &mut [Vec<u8>]) -> usize {
    let mut total = 0;
    for r in 0..grid.len() {
        for c in 0..grid[0].len() {
            grid[r][c] += 1;
            if grid[r][c] == 9 + 1 {
                total += flash(grid, r, c);
            }
        }
    }
    let mut check = 0;
    for row in grid {
        for c in row {
            if *c > 9 {
                check += 1;
                *c = 0;
            }
        }
    }
    assert_eq!(check, total);
    total
}

#[aoc(day11, part1, jorendorff)]
fn part_1(grid: &[Vec<u8>]) -> usize {
    let mut grid = grid.to_vec();
    (0..100).map(|_| step(&mut grid)).sum()
}

#[aoc(day11, part2, jorendorff)]
fn part_2(grid: &[Vec<u8>]) -> usize {
    let mut grid = grid.to_vec();
    for i in 1.. {
        if step(&mut grid) == 100 {
            return i;
        }
    }
    unreachable!();
}

#[cfg(test)]
mod tests {
    use super::*;

    const EXAMPLE: &str = "\
5483143223
2745854711
5264556173
6141336146
6357385478
4167524645
2176841721
6882881134
4846848554
5283751526
";

    static EXPECTED: &[(usize, &str)] = &[
        (
            1,
            "\
6594254334
3856965822
6375667284
7252447257
7468496589
5278635756
3287952832
7993992245
5957959665
6394862637
",
        ),
        (
            2,
            "\
8807476555
5089087054
8597889608
8485769600
8700908800
6600088989
6800005943
0000007456
9000000876
8700006848
",
        ),
        (
            3,
            "\
0050900866
8500800575
9900000039
9700000041
9935080063
7712300000
7911250009
2211130000
0421125000
0021119000
",
        ),
        (
            4,
            "\
2263031977
0923031697
0032221150
0041111163
0076191174
0053411122
0042361120
5532241122
1532247211
1132230211
",
        ),
        (
            5,
            "\
4484144000
2044144000
2253333493
1152333274
1187303285
1164633233
1153472231
6643352233
2643358322
2243341322
",
        ),
        (
            6,
            "\
5595255111
3155255222
3364444605
2263444496
2298414396
2275744344
2264583342
7754463344
3754469433
3354452433
",
        ),
        (
            7,
            "\
6707366222
4377366333
4475555827
3496655709
3500625609
3509955566
3486694453
8865585555
4865580644
4465574644
",
        ),
        (
            8,
            "\
7818477333
5488477444
5697666949
4608766830
4734946730
4740097688
6900007564
0000009666
8000004755
6800007755
",
        ),
        (
            9,
            "\
9060000644
7800000976
6900000080
5840000082
5858000093
6962400000
8021250009
2221130009
9111128097
7911119976
",
        ),
        (
            10,
            "\
0481112976
0031112009
0041112504
0081111406
0099111306
0093511233
0442361130
5532252350
0532250600
0032240000
",
        ),
        (
            20,
            "\
3936556452
5686556806
4496555690
4448655580
4456865570
5680086577
7000009896
0000000344
6000000364
4600009543
",
        ),
        (
            30,
            "\
0643334118
4253334611
3374333458
2225333337
2229333338
2276733333
2754574565
5544458511
9444447111
7944446119
",
        ),
        (
            40,
            "\
6211111981
0421111119
0042111115
0003111115
0003111116
0065611111
0532351111
3322234597
2222222976
2222222762
",
        ),
        (
            50,
            "\
9655556447
4865556805
4486555690
4458655580
4574865570
5700086566
6000009887
8000000533
6800000633
5680000538
",
        ),
        (
            60,
            "\
2533334200
2743334640
2264333458
2225333337
2225333338
2287833333
3854573455
1854458611
1175447111
1115446111
",
        ),
        (
            70,
            "\
8211111164
0421111166
0042111114
0004211115
0000211116
0065611111
0532351111
7322235117
5722223475
4572222754
",
        ),
        (
            80,
            "\
1755555697
5965555609
4486555680
4458655580
4570865570
5700086566
7000008666
0000000990
0000000800
0000000000
",
        ),
        (
            90,
            "\
7433333522
2643333522
2264333458
2226433337
2222433338
2287833333
2854573333
4854458333
3387779333
3333333333
",
        ),
        (
            100,
            "\
0397666866
0749766918
0053976933
0004297822
0004229892
0053222877
0532222966
9322228966
7922286866
6789998766
",
        ),
    ];

    #[test]
    fn test_step() {
        let mut board = parse_input(EXAMPLE).unwrap();
        let mut steps = 0;

        for &(time, state) in EXPECTED {
            let state = parse_input(state).unwrap();
            while steps < time {
                step(&mut board);
                steps += 1;
            }
            assert_eq!(board, state, "Step {}", steps);
        }
    }

    #[test]
    fn test_part_1() {
        assert_eq!(part_1(&parse_input(EXAMPLE).unwrap()), 1656);
    }

    #[test]
    fn test_part_2() {
        assert_eq!(part_2(&parse_input(EXAMPLE).unwrap()), 195);
    }
}
